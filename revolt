#! /usr/bin/env python3
# -*- coding: utf-8 -*-
# vim:fenc=utf-8
#
# Copyright © 2016 Adrian Perez <aperez@igalia.com>
#
# Distributed under terms of the MIT license.

import gi, os
gi.require_version('WebKit2', '4.0')

from gi.repository import WebKit2, Gtk, GLib, Gio, Gdk, GdkPixbuf

APP_ID = "org.perezdecastro.Revolt"
APP_COMMENTS = u"Desktop application for Riot.im"
APP_WEBSITE = u"https://github.com/aperezdc/revolt"
APP_AUTHORS = (
    u"Adrián Pérez de Castro <aperez@igalia.com>",
    u"Jacobo Aragunde Pérez <jaragunde@igalia.com>",
    u"Carlos López Pérez <clopez@igalia.com>",
)


def _find_resources_path():
    from os import environ, path as P
    devel = environ.get("__REVOLT_DEVELOPMENT")
    if devel and devel.strip():
        # Use the directory where the executable is located, most likely
        # a checkout of the Git repository.
        path = P.dirname(__file__)
    else:
        # Use an installed location: binary is in <prefix>/bin/revolt,
        # and resources in <prefix>/share/revolt/*
        path = P.join(P.dirname(P.dirname(__file__)), "share", "revolt")
    location = P.abspath(P.join(path, APP_ID + ".gresource"))
    print("* Resources:", location)
    return location

class SysTrayStatusIcon(object):
    def __init__(self, app, initial_status):
        self._status_icons = {
                    'connected' : APP_ID + '.status.online',
                    'disconnected' : APP_ID + '.status.offline',
                    'flip' : APP_ID + '.status.online',
                    'flop' : APP_ID + '.status.blink',
                    }
        self._tooltip_text_no_notifications = "Riot IM: 0 notifications"
        self.__app = app
        self._size = 16
        self._flipflop = True
        self._blinkmilliseconds = 500
        self._icon = self.__create_icon()
        self._contextmenu = self.__create_context_menu()
        self._icondata = {}
        self.__load_icons(self._size)
        self.set_status(initial_status)
        self.clear_notifications()

    def __add_notification_tooltip_text(self, text):
        if self._tooltip_text == self._tooltip_text_no_notifications:
            self._tooltip_text = ""
        self._tooltip_text +=  text
        self._tooltip_text +=  "\n"

    def __clear_notification_tooltip_text(self):
        self._tooltip_text = self._tooltip_text_no_notifications

    def __create_icon(self):
        icon = Gtk.StatusIcon().new()
        icon.set_visible(True)
        icon.set_property('has-tooltip', True)
        icon.set_property('title', 'Riot IM')
        icon.connect('activate', self.__on_left_click)
        icon.connect('popup-menu', self.__on_right_click)
        icon.connect('query-tooltip', self.__on_query_tooltip)
        icon.connect('size-changed', self.__on_icon_size_change)
        return icon

    def __create_context_menu(self):
        contextmenu = Gtk.Menu()
        # Settings
        settings = Gtk.MenuItem()
        settings.set_label("Settings")
        settings.connect("activate", self.__on_context_menu_settings)
        contextmenu.append(settings)
        # Quit
        quit = Gtk.MenuItem()
        quit.set_label("Quit")
        quit.connect("activate", self.__on_context_menu_quit)
        contextmenu.append(quit)
        return contextmenu

    def __load_icons(self, size):
        self._size = size
        for status in self._status_icons:
            self._icondata[status] = Gtk.IconTheme.get_default().load_icon(self._status_icons[status], int(size), 0)

    def __draw_icon(self, status=None):
        if status is None:
            status = self.status
        if status == "blinking":
            if self._flipflop:
                self._icon.set_from_pixbuf(self._icondata["flip"])
            else:
                self._icon.set_from_pixbuf(self._icondata["flop"])
        else:
            self._icon.set_from_pixbuf(self._icondata[status])
        return False

    def __on_context_menu_quit(self, widget):
        self.__app.quit()

    def __on_context_menu_settings(self, widget):
        self.__app.load_settings_page()
        self.__app.show()

    def __on_left_click(self, widget):
        self.clear_notifications()
        self.__app.show()

    def __on_right_click(self, icon, button, time):
        self._contextmenu.show_all()
        self._contextmenu.popup(None, None, None, self._icon, button, time)

    def __on_query_tooltip(self, widget, x, y, keyboard_mode, tooltip):
        self._icon.set_tooltip_text(self._tooltip_text)

    def __on_icon_size_change(self, statusicon, size):
        if size > 31:
            icon_size = '32'
        elif size > 23:
            icon_size = '24'
        else:
            icon_size = '16'
        # detect KDE session. see gajim bug #5476
        if os.environ.get('KDE_FULL_SESSION') == 'true':
            icon_size = '32'
        # detect MATE session.
        if os.environ.get('MATE_DESKTOP_SESSION_ID'):
            icon_size = '16'
        self.__load_icons(icon_size)
        self.__draw_icon()

    def __blink(self):
        self._flipflop = not self._flipflop
        self.__draw_icon()
        return self.status == "blinking"

    def add_notification(self, text):
        self.__add_notification_tooltip_text(text)
        self.set_status("blinking")

    def clear_notifications(self):
        self.__clear_notification_tooltip_text()
        if self.status == "blinking":
            self.set_status("connected")

    def set_status(self, status):
        valid_status = [ "disconnected", "connected", "blinking" ]
        if status not in valid_status:
            raise ValueError("Status %s is not valid. Allowed values are: %s" %(status,valid_status))
        if status == "blinking":
            # We only want one blink callback active at a time.
            if self.status != "blinking":
                GLib.timeout_add(self._blinkmilliseconds, self.__blink)
        else:
            GLib.timeout_add(2 * self._blinkmilliseconds, self.__draw_icon, status)
        self.status = status

class MainWindow(object):
    def __init__(self, app):
        self.__app = app
        self._webctx = self.__create_web_context()
        self._contentmgr = self.__create_content_manager()
        self.__create_widgets()
        self.__connect_widgets()
        self.__notification_ids = set()

    def __create_web_context(self):
        ctx = WebKit2.WebContext.get_default()
        ctx.set_web_process_count_limit(1)
        ctx.set_spell_checking_enabled(False)
        ctx.set_tls_errors_policy(WebKit2.TLSErrorsPolicy.FAIL)
        return ctx

    def __create_content_manager(self):
        mgr = WebKit2.UserContentManager()
        script = WebKit2.UserScript("Notification.requestPermission();",
                                    WebKit2.UserContentInjectedFrames.TOP_FRAME,
                                    WebKit2.UserScriptInjectionTime.START,
                                    None, None)
        mgr.add_script(script)
        return mgr

    def __create_widgets(self):
        header = Gtk.HeaderBar()
        header.set_show_close_button(True)

        self.__app.settings.bind("riot-url", header, "subtitle",
                Gio.SettingsBindFlags.DEFAULT)
        header.set_has_subtitle(True)

        self._spinner = Gtk.Spinner()
        header.pack_end(self._spinner)

        self._window = Gtk.ApplicationWindow()
        self._window.set_titlebar(header)
        self._window.set_title("Revolt")
        self._window.set_default_icon_name(APP_ID)
        self._window.set_default_size(980, 650)
        self.__app.add_window(self._window)

        self._webview = WebKit2.WebView(user_content_manager=self._contentmgr,
                                        web_context=self._webctx)
        self._webview.connect("decide-policy", self.__on_decide_policy)
        self.__app.settings.bind("zoom-factor", self._webview, "zoom-level",
                Gio.SettingsBindFlags.DEFAULT)
        if hasattr(self._webview, "set_maintains_back_forward_list"):
            self._webview.set_maintains_back_forward_list(False)
        websettings = self._webview.get_settings()
        websettings.set_allow_file_access_from_file_urls(True)
        websettings.set_allow_modal_dialogs(False)  # TODO
        websettings.set_enable_fullscreen(False)
        websettings.set_enable_java(False)
        websettings.set_enable_media_stream(True)
        websettings.set_enable_page_cache(False)  # Single-page app
        websettings.set_enable_plugins(False)
        websettings.set_enable_smooth_scrolling(True)
        websettings.set_enable_webaudio(True)
        websettings.set_enable_write_console_messages_to_stdout(True)
        websettings.set_javascript_can_access_clipboard(True)
        websettings.set_minimum_font_size(12)  # TODO: Make it a setting
        websettings.set_property("enable-mediasource", True)
        self._window.add(self._webview)

    def __on_decide_policy(self, webview, decision, decision_type):
        if decision_type == WebKit2.PolicyDecisionType.NAVIGATION_ACTION:
            if decision.get_navigation_type() == WebKit2.NavigationType.LINK_CLICKED:
                uri = decision.get_request().get_uri()
                if not uri.startswith(self.__app.riot_url):
                    Gtk.show_uri(uri)
                    return True
        elif decision_type == WebKit2.PolicyDecisionType.NEW_WINDOW_ACTION:
            if decision.get_navigation_type() == WebKit2.NavigationType.LINK_CLICKED:
                Gtk.show_uri(None, decision.get_request().get_uri(), Gdk.CURRENT_TIME)
                return True
        return False

    def __on_has_toplevel_focus_changed(self, window, has_focus):
        assert window == self._window
        if window.has_toplevel_focus():
            # Clear the window's urgency hint
            window.set_urgency_hint(False)
            # Dismiss notifications
            for notification_id in self.__notification_ids:
                self.__app.withdraw_notification(notification_id)
            self.__notification_ids.clear()
            self.__app.statusicon.clear_notifications()

    def __on_window_close(self, window):
        # TODO: Do cleanup here
        window.hide()
        return False

    def __on_load_changed(self, webview, event):
        if event == WebKit2.LoadEvent.FINISHED:
            self._spinner.stop()
            self.__app.statusicon.set_status("connected")
        else:
            self.__app.statusicon.set_status("disconnected")
            self._spinner.start()

    def __on_show_notification(self, webview, notification):
        # TODO: Handle notification clicked, and so
        if not self._window.has_toplevel_focus():
            self._window.set_urgency_hint(True)
            notif = Gio.Notification.new(notification.get_title())
            notif.set_body(notification.get_body())
            notif.set_icon(Gio.ThemedIcon.new(APP_ID))
            notif.set_priority(Gio.NotificationPriority.HIGH)
            # use title as notification id:
            # allows to reuse one notification for the same conversation
            notification_id = notification.get_title()
            self.__notification_ids.add(notification_id)
            self.__app.send_notification(notification_id, notif)
            self.__app.statusicon.add_notification("%s: %s" %(notification.get_title(), notification.get_body()))
        return True

    def __on_permission_request(self, webview, request):
        if isinstance(request, WebKit2.NotificationPermissionRequest):
            request.allow()
            return True

    def __connect_widgets(self):
        self._window.connect("destroy", self.__on_window_close)
        self._window.connect("notify::has-toplevel-focus", self.__on_has_toplevel_focus_changed)
        self._webview.connect("load-changed", self.__on_load_changed)
        self._webview.connect("show-notification", self.__on_show_notification)
        self._webview.connect("permission-request", self.__on_permission_request)

    def load_riot(self):
        self._webview.load_uri(self.__app.riot_url)
        return self

    def load_settings_page(self):
        current_url = self._webview.get_uri()
        if '#' in current_url:
            settings_url = current_url.split('#',1)[0] + '#/settings'
            self._webview.load_uri(settings_url)
        else:
            raise ValueError("Unknown base URL schema: %s" %current_url)

    def show(self):
        self._window.show_all()
        self._window.present()
        return self

    def finish(self):
        print("Finish...")
        self._webview.stop_loading()
        self._window.hide()
        self._window.destroy()
        del self._webview
        return self


class App(Gtk.Application):
    def __init__(self):
        Gtk.Settings.get_default().set_property("gtk-application-prefer-dark-theme", True)
        Gio.Resource.load(_find_resources_path())._register()
        Gtk.Application.__init__(self,
                application_id = APP_ID,
                flags = Gio.ApplicationFlags.FLAGS_NONE)
        self.settings = Gio.Settings.new(APP_ID)
        self.riot_url = self.settings.get_string("riot-url")
        self.window = None
        self.statusicon = SysTrayStatusIcon(self, 'disconnected')
        self.connect("shutdown", self.__on_shutdown)
        self.connect("activate", self.__on_activate)
        self.connect("startup", self.__on_startup)

    def __action(self, name, callback):
        action = Gio.SimpleAction.new(name)
        action.connect("activate", callback)
        self.add_action(action)

    def __on_startup(self, app):
        print("* App Startup...")
        self.__action("quit", lambda *arg: self.quit())
        self.__action("about", self.__on_app_about)
        self.__action("preferences", self.__on_app_preferences)

    def __on_shutdown(self, app):
        print("* App Shutdown...")
        if self.window is not None:
            self.window.finish()

    def __on_activate(self, app):
        print("* App Activated...")
        if self.window is None:
            self.window = MainWindow(self).load_riot()
        self.window.show()

    def __on_app_about(self, action, param):
        dialog = Gtk.AboutDialog(
                program_name=u"Revolt",
                authors=APP_AUTHORS,
                logo_icon_name=APP_ID,
                license_type=Gtk.License.GPL_3_0,
                comments=APP_COMMENTS,
                website=APP_WEBSITE)
        dialog.connect("response", lambda d, r: d.destroy())
        dialog.present()

    def __build(self, resource, *names):
        builder = Gtk.Builder.new_from_resource(self.get_resource_base_path() + "/" + resource)
        return (builder.get_object(name) for name in names)

    def __on_app_preferences(self, action, param):
        window, url_entry, zoom_factor, zoom_factor_reset = self.__build("gtk/preferences.ui",
                "settings-window", "riot-url-entry", "zoom-factor", "zoom-factor-reset")
        self.settings.bind("zoom-factor", zoom_factor, "value",
                Gio.SettingsBindFlags.DEFAULT)
        zoom_factor_reset.connect("clicked", lambda button:
                self.settings.set_double("zoom-factor", 1.0))
        url_entry.set_text(self.riot_url)
        def on_hide(window):
            new_url = url_entry.get_text()
            if new_url != self.riot_url:
                self.settings.set_string("riot-url", new_url)
                self.riot_url = new_url
                self.window.load_riot()
        window.connect("hide", on_hide)
        window.set_transient_for(self.window._window)  # XXX: Ugh.
        window.present()

    def load_settings_page(self):
        self.window.load_settings_page()

    def show(self):
        self.window.show()


if __name__ == "__main__":
    # Honor CTRL+C http://stackoverflow.com/q/16410852
    import signal, sys
    signal.signal(signal.SIGINT, signal.SIG_DFL)
    App().run(sys.argv[1:])
