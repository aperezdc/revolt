#! /usr/bin/env python3
# -*- coding: utf-8 -*-
# vim:fenc=utf-8
#
# Copyright © 2016 Adrian Perez <aperez@igalia.com>
#
# Distributed under terms of the MIT license.

import gi
import os

gi.require_version('WebKit2', '4.0')
from gi.repository import WebKit2, Gtk, GLib, Gio, Gdk, GObject  # noqa: E402


APP_ID = "org.perezdecastro.Revolt"
APP_COMMENTS = u"Desktop application for Riot.im"
APP_WEBSITE = u"https://github.com/aperezdc/revolt"
APP_AUTHORS = (
    u"Adrián Pérez de Castro <aperez@igalia.com>",
    u"Jacobo Aragunde Pérez <jaragunde@igalia.com>",
    u"Carlos López Pérez <clopez@igalia.com>",
)


def _find_resources_path():
    from os import environ, path as P
    devel = environ.get("__REVOLT_DEVELOPMENT")
    if devel and devel.strip():
        # Use the directory where the executable is located, most likely
        # a checkout of the Git repository.
        path = P.dirname(__file__)
    else:
        # Use an installed location: binary is in <prefix>/bin/revolt,
        # and resources in <prefix>/share/revolt/*
        path = P.join(P.dirname(P.dirname(__file__)), "share", "revolt")
    location = P.abspath(P.join(path, APP_ID + ".gresource"))
    print("* Resources:", location)
    return location


class SysTrayStatusIcon(object):
    ICON_STATUS_NAMES = ("connected", "disconnected", "flip", "flop")

    def __init__(self, app, initial_status):
        self._tooltip_text_no_notifications = "Revolt: 0 notifications"
        self.__app = app
        self._size = 16
        self._flipflop = True
        self._blinkmilliseconds = 500
        self._icon = self.__create_icon()
        self._contextmenu = \
            Gtk.Menu.new_from_model(self.__app.get_menu_by_id("app-menu"))
        self._contextmenu.insert_action_group("app", self.__app)
        self._icondata = {}
        self.__load_icons(self._size)
        self.set_status(initial_status)
        self.clear_notifications()

    def __add_notification_tooltip_text(self, text):
        if self._tooltip_text == self._tooltip_text_no_notifications:
            self._tooltip_text = ""
        self._tooltip_text += text
        self._tooltip_text += "\n"

    def __clear_notification_tooltip_text(self):
        self._tooltip_text = self._tooltip_text_no_notifications

    def __create_icon(self):
        icon = Gtk.StatusIcon()
        icon.set_visible(True)
        icon.set_property('has-tooltip', True)
        icon.set_property('title', 'Revolt')
        icon.connect('activate', self.__on_left_click)
        icon.connect('popup-menu', self.__on_right_click)
        icon.connect('query-tooltip', self.__on_query_tooltip)
        icon.connect('size-changed', self.__on_icon_size_change)
        return icon

    def __load_icons(self, size):
        self._size = size
        theme = Gtk.IconTheme.get_default()
        for status in self.ICON_STATUS_NAMES:
            self._icondata[status] = theme.load_icon("revolt-status-" + status, int(size), 0)

    def __draw_icon(self, status=None):
        if status is None:
            status = self.status
        if status == "blinking":
            if self._flipflop:
                self._icon.set_from_pixbuf(self._icondata["flip"])
            else:
                self._icon.set_from_pixbuf(self._icondata["flop"])
        else:
            self._icon.set_from_pixbuf(self._icondata[status])
        return False

    def __on_left_click(self, widget):
        self.clear_notifications()
        self.__app.show()

    def __on_right_click(self, icon, button, time):
        self._contextmenu.show_all()
        self._contextmenu.popup(None, None, None, self._icon, button, time)

    def __on_query_tooltip(self, widget, x, y, keyboard_mode, tooltip):
        self._icon.set_tooltip_text(self._tooltip_text)

    def __on_icon_size_change(self, statusicon, size):
        if size > 31:
            icon_size = '32'
        elif size > 23:
            icon_size = '24'
        else:
            icon_size = '16'
        # detect KDE session. see gajim bug #5476
        if os.environ.get('KDE_FULL_SESSION') == 'true':
            icon_size = '32'
        # detect MATE session.
        if os.environ.get('MATE_DESKTOP_SESSION_ID'):
            icon_size = '16'
        self.__load_icons(icon_size)
        self.__draw_icon()

    def __blink(self):
        self._flipflop = not self._flipflop
        self.__draw_icon()
        return self.status == "blinking"

    def add_notification(self, text):
        self.__add_notification_tooltip_text(text)
        self.set_status("blinking")

    def clear_notifications(self):
        self.__clear_notification_tooltip_text()
        if self.status == "blinking":
            self.set_status("connected")

    def set_status(self, status):
        valid_status = ["disconnected", "connected", "blinking"]
        if status not in valid_status:
            raise ValueError("Status %s is not valid. Allowed values are: %s" % (status, valid_status))
        if status == "blinking":
            # We only want one blink callback active at a time.
            if self.status != "blinking":
                GLib.timeout_add(self._blinkmilliseconds, self.__blink)
        else:
            GLib.timeout_add(2 * self._blinkmilliseconds, self.__draw_icon, status)
        self.status = status


class MainWindow(Gtk.ApplicationWindow):
    network_busy = GObject.Property(type=bool, default=False)

    def __init__(self, application):
        Gtk.ApplicationWindow.__init__(self,
                                       application=application,
                                       default_height=980,
                                       default_width=650,
                                       role="main-window",
                                       icon_name=application.get_application_id())
        self.application = application
        self.set_titlebar(self.__make_headerbar())
        self.set_title(u"Revolt")
        application.add_window(self)
        self._webview = WebKit2.WebView(user_content_manager=self.__create_content_manager(),
                                        web_context=self.__create_web_context())
        self._webview.connect("decide-policy", self.__on_decide_policy)
        application.settings.bind("zoom-factor", self._webview, "zoom-level",
                                  Gio.SettingsBindFlags.DEFAULT)
        if hasattr(self._webview, "set_maintains_back_forward_list"):
            self._webview.set_maintains_back_forward_list(False)
        websettings = self._webview.get_settings()
        application.settings.bind("enable-developer-tools", websettings,
                                  "enable-developer-extras",
                                  Gio.SettingsBindFlags.DEFAULT)
        websettings.set_allow_file_access_from_file_urls(True)
        websettings.set_allow_modal_dialogs(False)  # TODO
        websettings.set_enable_fullscreen(False)
        websettings.set_enable_java(False)
        websettings.set_enable_media_stream(True)
        websettings.set_enable_page_cache(False)  # Single-page app
        websettings.set_enable_plugins(False)
        websettings.set_enable_smooth_scrolling(True)
        websettings.set_enable_webaudio(True)
        websettings.set_enable_write_console_messages_to_stdout(True)
        websettings.set_javascript_can_access_clipboard(True)
        websettings.set_minimum_font_size(12)  # TODO: Make it a setting
        websettings.set_property("enable-mediasource", True)
        self._webview.show_all()
        self.add(self._webview)
        self.__connect_widgets()
        self.__notification_ids = set()

    def __make_headerbar(self):
        header = Gtk.HeaderBar()
        header.set_show_close_button(True)
        spinner = Gtk.Spinner()
        header.pack_end(spinner)
        self.bind_property("network-busy", spinner, "active",
                           GObject.BindingFlags.DEFAULT)
        header.show_all()
        return header

    def __create_web_context(self):
        ctx = WebKit2.WebContext.get_default()
        ctx.set_web_process_count_limit(1)
        ctx.set_spell_checking_enabled(False)
        ctx.set_tls_errors_policy(WebKit2.TLSErrorsPolicy.FAIL)
        return ctx

    def __create_content_manager(self):
        mgr = WebKit2.UserContentManager()
        script = WebKit2.UserScript("Notification.requestPermission();",
                                    WebKit2.UserContentInjectedFrames.TOP_FRAME,
                                    WebKit2.UserScriptInjectionTime.START,
                                    None, None)
        mgr.add_script(script)
        return mgr

    def __on_decide_policy(self, webview, decision, decision_type):
        if decision_type == WebKit2.PolicyDecisionType.NAVIGATION_ACTION:
            if decision.get_navigation_type() == WebKit2.NavigationType.LINK_CLICKED:
                uri = decision.get_request().get_uri()
                if not uri.startswith(self.application.riot_url):
                    Gtk.show_uri(uri)
                    return True
        elif decision_type == WebKit2.PolicyDecisionType.NEW_WINDOW_ACTION:
            if decision.get_navigation_type() == WebKit2.NavigationType.LINK_CLICKED:
                Gtk.show_uri(None, decision.get_request().get_uri(), Gdk.CURRENT_TIME)
                return True
        return False

    def __on_has_toplevel_focus_changed(self, window, has_focus):
        assert window == self
        if window.has_toplevel_focus():
            # Clear the window's urgency hint
            window.set_urgency_hint(False)
            # Dismiss notifications
            for notification_id in self.__notification_ids:
                self.application.withdraw_notification(notification_id)
            self.__notification_ids.clear()
            self.application.statusicon.clear_notifications()

    def __on_load_changed(self, webview, event):
        if event == WebKit2.LoadEvent.FINISHED:
            self.network_busy = False
            self.application.statusicon.set_status("connected")
        else:
            self.network_busy = True
            self.application.statusicon.set_status("disconnected")

    def __on_show_notification(self, webview, notification):
        # TODO: Handle notification clicked, and so
        if not self.has_toplevel_focus():
            self.set_urgency_hint(True)
            notif = Gio.Notification.new(notification.get_title())
            notif.set_body(notification.get_body())
            notif.set_icon(Gio.ThemedIcon.new(APP_ID))
            notif.set_priority(Gio.NotificationPriority.HIGH)
            # use title as notification id:
            # allows to reuse one notification for the same conversation
            notification_id = notification.get_title()
            self.__notification_ids.add(notification_id)
            self.application.send_notification(notification_id, notif)
            self.application.statusicon.add_notification("%s: %s" % (notification.get_title(),
                                                                     notification.get_body()))
        return True

    def __on_permission_request(self, webview, request):
        if isinstance(request, WebKit2.NotificationPermissionRequest):
            request.allow()
            return True

    def __connect_widgets(self):
        self.connect("notify::has-toplevel-focus", self.__on_has_toplevel_focus_changed)
        self._webview.connect("load-changed", self.__on_load_changed)
        self._webview.connect("show-notification", self.__on_show_notification)
        self._webview.connect("permission-request", self.__on_permission_request)

    def load_riot(self):
        self._webview.load_uri(self.application.riot_url)
        return self

    def load_settings_page(self):
        from urllib.parse import urlsplit, urlunsplit
        url = list(urlsplit(self._webview.get_uri()))
        url[-1] = "#settings"
        self._webview.load_uri(urlunsplit(url))

    def finish(self):
        print("Finish...")
        self._webview.stop_loading()
        self.hide()
        self.destroy()
        del self._webview
        return self


class App(Gtk.Application):
    def __init__(self):
        Gtk.Settings.get_default().set_property("gtk-application-prefer-dark-theme", True)
        Gio.Resource.load(_find_resources_path())._register()
        Gtk.Application.__init__(self, application_id=APP_ID,
                                 flags=Gio.ApplicationFlags.FLAGS_NONE)
        self.settings = Gio.Settings.new(APP_ID)
        self.riot_url = self.settings.get_string("riot-url")
        self.window = None
        self.statusicon = None
        self.connect("shutdown", self.__on_shutdown)
        self.connect("activate", self.__on_activate)
        self.connect("startup", self.__on_startup)

    def __action(self, name, callback):
        action = Gio.SimpleAction.new(name)
        action.connect("activate", callback)
        self.add_action(action)

    def __on_startup(self, app):
        print("* App Startup...")
        self.statusicon = SysTrayStatusIcon(self, 'disconnected')
        self.__action("quit", lambda *arg: self.quit())
        self.__action("about", self.__on_app_about)
        self.__action("preferences", self.__on_app_preferences)
        self.__action("riot-settings", self.__on__riot_settings)

    def __on_shutdown(self, app):
        print("* App Shutdown...")
        if self.window is not None:
            self.window.finish()

    def __on_activate(self, app):
        print("* App Activated...")
        if self.window is None:
            self.window = MainWindow(self).load_riot()
        self.show()

    def __on_app_about(self, action, param):
        dialog = Gtk.AboutDialog(
                program_name=u"Revolt",
                authors=APP_AUTHORS,
                logo_icon_name=APP_ID,
                license_type=Gtk.License.GPL_3_0,
                comments=APP_COMMENTS,
                website=APP_WEBSITE)
        dialog.connect("response", lambda d, r: d.destroy())
        dialog.present()

    def __build(self, resource, *names):
        builder = Gtk.Builder.new_from_resource(self.get_resource_base_path() + "/" + resource)
        return (builder.get_object(name) for name in names)

    def __on_app_preferences(self, action, param):
        window, url_entry, zoom_factor, zoom_factor_reset, devtools_toggle = \
                self.__build("gtk/preferences.ui",
                             "settings-window",
                             "riot-url-entry",
                             "zoom-factor",
                             "zoom-factor-reset",
                             "dev-tools-toggle")
        self.settings.bind("zoom-factor", zoom_factor, "value",
                           Gio.SettingsBindFlags.DEFAULT)
        self.settings.bind("enable-developer-tools", devtools_toggle, "active",
                           Gio.SettingsBindFlags.DEFAULT)
        zoom_factor_reset.connect("clicked", lambda button:
                                  self.settings.set_double("zoom-factor", 1.0))
        url_entry.set_text(self.riot_url)

        def on_hide(window):
            new_url = url_entry.get_text()
            if new_url != self.riot_url:
                self.settings.set_string("riot-url", new_url)
                self.riot_url = new_url
                self.window.load_riot()
        window.connect("hide", on_hide)
        window.set_transient_for(self.window)
        window.present()

    def __on__riot_settings(self, action, param):
        self.show()
        self.window.load_settings_page()

    def show(self):
        self.window.show()
        self.window.present()


if __name__ == "__main__":
    # Honor CTRL+C http://stackoverflow.com/q/16410852
    import signal
    import sys
    signal.signal(signal.SIGINT, signal.SIG_DFL)
    App().run(sys.argv[1:])
